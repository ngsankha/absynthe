#!/usr/bin/env ruby

require "bundler/setup"
require "absynthe"
require "absynthe/python"
require "json"
require "rdl"
require "fc"
require "pp"

class DataFrame; end
class Series; end
class Lambda; end
class NUnique < Lambda; end
class Type; end
class PyInt < Type; end
class DataFrameGroupBy; end

RDL.type_params :Array, [:t], :all?
RDL.type :DataFrame, :loc_getitem, "(Array<Integer>) -> DataFrame"
RDL.type :DataFrame, :loc_getitem, "(Lambda) -> DataFrame"
RDL.type :DataFrame, :xs, "(String, level: 0 or 1) -> DataFrame"
RDL.type :DataFrame, :pivot, "(columns: String, values: String, index: String) -> DataFrame"
RDL.type :DataFrame, :sort_values, "(by: Array<String>, ascending: Array<true or false>) -> DataFrame"
RDL.type :DataFrame, :sort_values, "(Array<String>, ascending: Array<true or false>) -> DataFrame"
RDL.type :DataFrame, :combine_first, "(DataFrame) -> DataFrame"
RDL.type :DataFrame, :pivot_table, "(values: String, index: String, columns: String, aggfunc: Lambda) -> DataFrame"
RDL.type :DataFrame, :pivot_table, "(values: String, index: String, columns: String, aggfunc: String) -> DataFrame"
RDL.type :DataFrame, :pivot_table, "(values: String, index: String, columns: Array<String>, aggfunc: Lambda) -> DataFrame"
RDL.type :DataFrame, :merge, "(DataFrame, on: Integer) -> DataFrame"
RDL.type :DataFrame, :merge, "(DataFrame, on: Array<String>) -> DataFrame"
RDL.type :DataFrame, :__getitem__, "(Series) -> DataFrame"
RDL.type :DataFrame, :apply, "(Lambda, axis: 0 or 1) -> Series"
RDL.type :DataFrame, :query, "(String) -> DataFrame"
RDL.type :DataFrame, :fillna, "(method: String) -> DataFrame"
RDL.type :DataFrame, :astype, "(Type) -> DataFrame"
RDL.type :DataFrame, :stack, "() -> DataFrame"
RDL.type :DataFrame, :unstack, "() -> DataFrame"
RDL.type :DataFrame, :groupby, "(Array<String>) -> DataFrameGroupBy"
RDL.type :DataFrameGroupBy, :size, "() -> Series"
RDL.type :DataFrame, :dropna, '() -> DataFrame'
RDL.type :DataFrame, :reset_index, '(drop: true or false) -> DataFrame'

$stdout.sync = true

class Protocol
  def self.read
    l = gets
    return if l.nil? # process ended
    data = JSON.parse(l)
    # TODO: additional parsing
    data
  end

  def self.write(data)
    puts data.to_json
  end
end

class PythonSpec
  def test_prog(prog)
    Protocol.write({
      action: 'test',
      prog: PyLang::unparse(prog)
    })
    handle_action(Protocol.read)
  end
end

class PyLang
  def self.unparse(node, in_arg: false)
    case node.type
    when :const
      konst = node.children[0]
      case konst
      when Integer, Symbol
        konst.to_s
      when true
        'True'
      when false
        'False'
      when NUnique
        'pd.Series.nunique'
      when PyInt
        'int'
      when String
        konst.inspect
      else
        raise AbsyntheError, "unexpected constant type"
      end
    when :prop
      recv = unparse(node.children[0])
      propname = node.children[1].to_s
      if propname == "loc_getitem"
        propname = ".loc"
      elsif propname == "__getitem__"
        propname = ""
      end
      args = node.children[2..].map { |n| unparse(n) }.join(", ")
      "#{recv}#{propname}[#{args}]"
    when :send
      recv = unparse(node.children[0])
      methd_name = node.children[1].to_s
      args = node.children[2..].map { |n| unparse(n, in_arg: true) }.join(", ")
      "#{recv}.#{methd_name}(#{args})"
    when :key
      val = unparse(node.children[1])
      "#{node.children[0]}=#{val}"
    when :hash
      raise AbsyntheError, "only expected in_arg" unless in_arg
      node.children.map { |kv| unparse(kv) }. join(", ")
    when :array
      args = node.children.map { |n| unparse(n) }.join(", ")
      "[#{args}]"
    when :hole
      # "(□: #{node.children[1]})"
      "□"
    when :dephole
      # "(□: #{node.children[1]})"
      "◐"
    else
      raise AbsyntheError, "unexpected AST node #{node.type}"
    end
  end
end

def parse_rownum(data)
  [data['rownumin'].map { |n|
      if n == "top"
        PandasRows.top
      else
        PandasRows.val(n)
      end
    },
   PandasRows.val(data['rownumout'])]
end

def syn_start(data)
  argsty = data['argsty']
  fnty = RDL::Globals.parser.scan_str("(#{argsty.join(', ')}) -> #{data['outputty']}")
  # rownum_in, rownum_out = parse_rownum(data)
  spec = PythonSpec.new

  tyargs = fnty.args.map { |ty| PyType.val(ty) }

  # abs_env = tyargs.zip(rownum_in).each_with_index.map { |arg, i| ["arg#{i}".to_sym,
  #   ProductDomain.val(arg[0], arg[1])]}.to_h
  abs_env = tyargs.each_with_index.map { |arg, i| ["arg#{i}".to_sym, arg]}.to_h
  # ctx = Context.new(abs_env, ProductDomain.val(PyType.val(fnty.ret), rownum_out))
  ctx = Context.new(abs_env, PyType.val(fnty.ret))
  ctx.lang = :py
  # ctx.domain = ProductDomain
  ctx.domain = PyType
  ctx.score = Proc.new { |prog| WeightedSizePass.prog_size(prog) }
  seed = s(:hole, nil, ctx.goal)
  q = FastContainers::PriorityQueue.new(:min)
  q.push(seed, ProgSizePass.prog_size(seed))
  prog = synthesize(ctx, spec, q)
  Protocol.write({
    action: 'done',
    prog: PyLang::unparse(prog)
  })
end

def handle_action(data)
  case data['action']
  when 'start'
    syn_start(data)
    puts data
  when 'test_res'
    data['res']
  else
    raise AbsyntheError, "unexpected action #{data}"
  end
end

Instrumentation.reset!
handle_action(Protocol.read)
# handle_action({'args': ['DataFrame'], 'output': 'DataFrame', 'action': 'start'}.transform_keys(&:to_s))
